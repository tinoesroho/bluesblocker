import type { Settings } from './common/settings.types';
import { Settings } from './common/settings.types';
var slowYourRoll = 1000;

chrome.runtime.onInstalled.addListener(() => {
	chrome.alarms.create({
		periodInMinutes: 1,
	});
});

chrome.alarms.onAlarm.addListener(doQueueLoop(20, 2, 60));

// generated by bing
chrome.runtime.onStartup.addListener(function() {
  chrome.storage.sync.get(null, function(items) {
    if (Object.keys(items).length === 0) {
      console.log('chrome.storage.sync is empty');
    } else {
      chrome.storage.local.set(items);
      console.log('Copied contents of chrome.storage.sync to chrome.storage.local');
	  chrome.storage.sync.clear(); 
    }
  });
});
/* i asked bing to create some functions, then started taping them together. then i thought better and asked it to make tha above.
chrome.runtime.onStartup.addListener {
const StorageBinEmpty = true;
chrome.storage.sync.get(null, function(items) {
  if (Object.keys(items).length === 0) {
    console.log('chrome.storage.sync is empty');
	
  } else {
    console.log('chrome.storage.sync is not empty');
	StorageBinEmpty = false;
  }
});

if (!StorageBinEmpty){
chrome.storage.sync.get(null, function(items) {
  chrome.storage.local.set(items);
});
chrome.storage.sync.clear(); 
}
}
*/
/*
// code borrowed from StackOverflow answer by Xan
// https://stackoverflow.com/a/29064381
// event.js, goes into background.scripts in manifest

// Those will not persist if event page is unloaded

var Synchertimeout;
var queuedChanges = {};
var syncStamp = 1;

chrome.storage.onChanged.addListener(function(changes, area) {
  // Check if it's an echo of our changes
  if(changes._syncStamp && changes._syncStamp.newValue == syncStamp) {
    return;
  }

  if(area == "local") {
    // Change in local storage: queue a flush to sync

    // Reset timeout
    if(Synchertimeout) { clearTimeout(Synchertimeout); }

    // Merge changes with already queued ones
    for(var key in changes) {
      // Just overwrite old change; we don't care about last newValue
      queuedChanges[key] = changes[key];
    }

    // Schedule flush
    Synchertimeout = setTimeout(flushToSync, 5000);

  } else {
    // Change in sync storage: copy to local

    if(changes._syncStamp && changes._syncStamp.newValue) {
      // Ignore those changes when they echo as local
      syncStamp = changes._syncStamp.newValue;
    }
    commitChanges(changes, chrome.storage.local);
  }
});

function flushToSync() {
  // Be mindful of what gets synced: there are also size quotas
  // If needed, filter queuedChanges here

  // Generate a new sync stamp
  // With random instead of sequential, there's a really tiny chance
  //   changes will be ignored, but no chance of stamp overflow
  syncStamp = Math.random();
  queuedChanges._syncStamp = {newValue: syncStamp};

  // Process queue for committing
  commitChanges(queuedChanges, chrome.storage.sync);

  // Reset queue
  queuedChanges = {};
  Synchertimeout = undefined;
}

function commitChanges(changes, storage) {
  var setData = {};

  for(var key in changes) {
    setData[key] = changes[key].newValue;
  }

  storage.set(setData, function() {
    if(chrome.runtime.lastError) {
      console.error(chrome.runtime.lastError.message);
    }
  });
}

// end borrowed code
*/

function doQueueLoop(
	secondsBetweenActions: number,
	randomness: number,
	totalSeconds: number
) {
	return () => {
		const startTime = Date.now();
		console.log('alarm called', startTime);
		chrome.storage.local.get(['slowYourRoll'], function(result) {
			slowYourRoll = result.slowYourRoll;
			console.log('Value currently is ' + slowYourRoll);
		});
		const fn = async () => {
			const [queue, whitelist] = await getActionQueue();
			const action = getFirstUndone(queue, whitelist);
			if (action) {
				await performAction(action, queue);
				const timeout =
					(secondsBetweenActions + (Math.random() - 0.5) * randomness) * (slowYourRoll * 1000);
				if (Date.now() + timeout - startTime < totalSeconds * slowYourRoll * 1000) {
					setTimeout(fn, timeout);
				}
			}
		};
		fn();
	};
}

async function doubleTap (name_to_tap){
const rollRandomness = Math.floor(Math.random() * 3);
const timeoutDoubletap = (((Math.random() - 0.5) * rollRandomness) * (slowYourRoll * 1000) * 5);
setTimeout(function(){
fetchApi('/mutes/users/create.json','user_id=' + name_to_tap);
var time = new Date();
var currentTimeLocalized = time.toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', hour12: true });
console.log("Doubletapped " + name_to_tap + " at " + currentTimeLocalized);
},timeoutDoubletap);
}

async function performAction(
	action: Settings['actionQueue'][number],
	queue: Settings['actionQueue']
) {
	console.log('Performing action:', action);
	let result: 'success' | 'retry' | 'fail' | 'delay';
	switch (action.action) {
		case 'block':
			result = await fetchApi('/blocks/create.json', 'user_id=' + action.id);
			var time = new Date();
			var currentTimeLocalized = time.toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', hour12: true });
			console.log("Blocked " + action.id + " at " + currentTimeLocalized);
			doubleTap(action.id);
			break;
		case 'follow':
			result = await fetchApi(
				'/friendships/create.json',
				'user_id=' + action.id
			);
			break;
		case 'mute':
			result = await fetchApi(
				'/mutes/users/create.json',
				'user_id=' + action.id
			);
			break;
		default:
			result = 'success';
			break;
	}
	console.log('Result:', result);
	switch (result) {
		case 'success':
		case 'fail': {
			action.doneAt = Date.now();
			await new Promise<void>((resolve) => {
				chrome.storage.local.set({ actionQueue: queue }, () => resolve());
			});
			break;
		}
		case 'retry':
			break;
		case 'delay': {
			queue.push(queue.splice(queue.indexOf(action), 1)[0]);
			await new Promise<void>((resolve) => {
				chrome.storage.local.set({ actionQueue: queue }, () => resolve());
			});
			break;
		}
	}
}

function getFirstUndone(
	queue: Settings['actionQueue'],
	whitelist: Settings['whitelistedUsers']
) {
	const whitelistSet = new Set(whitelist.map((w) => w.id));
	for (let i = 0; i < queue.length; i++) {
		// If it's undone
		if (queue[i].doneAt === undefined && !whitelistSet.has(queue[i].id)) {
			const lastDone = queue[i - 1]?.doneAt;
			// Do it if the last one is undone
			if (!lastDone) return queue[i];
			const timeSinceLast = Date.now() - lastDone;
			// If it's been more than 10 seconds
			if (timeSinceLast > 10000) return queue[i];
			else return undefined;
		}
	}
	return undefined;
}

function getActionQueue(): Promise<
	[Settings['actionQueue'], Settings['whitelistedUsers']]
> {
	return new Promise((r) => {
		chrome.storage.local.get(['actionQueue', 'whitelistedUsers'], (settings) => {
			const { actionQueue, whitelistedUsers } = settings as Settings;
			r([actionQueue ?? [], whitelistedUsers ?? []]);
		});
	});
}

function fetchApi(path: string, body: string) {
	return new Promise<'success' | 'retry' | 'fail' | 'delay'>((r) => {
		chrome.cookies.get(
			{ url: 'https://twitter.com', name: 'ct0' },
			async (cookie) => {
				if (!cookie) return r('retry');
				const res = await fetch('https://twitter.com/i/api/1.1' + path, {
					method: 'POST',
					headers: {
						Authorization: 'Bearer ' + 'AAAAAAAAAAAAAAAAAAAAANRILgAAAAAAnNwIzUejRCOuH5E6I8xnZz4puTs%3D1Zv7ttfk8LF81IUq16cHjhLTvJu4FA33AGWWjCpTnA',
						'Content-Type': 'application/x-www-form-urlencoded',
						'x-twitter-active-user': 'yes',
						'x-csrf-token': cookie.value,
						'x-twitter-auth-type': 'OAuth2Session',
						'x-twitter-client-language': 'en',
					},
					credentials: 'include',
					mode: 'cors',
					body,
				});
				if (res.status !== 200) r('delay');

				r('success');
			}
		);
	});
}